#version 460 core
// fragment shader

in vec2 TexCoords;
in vec3 CamPosition;
in vec3 VPosition;
in vec3 VNormal;
out vec4 FragColor;

const int TEXTYPES_NUM = 3;

//uniform means accept value from C++
//sampler2D is a texture file
//openGL stores texture files as integers in an array
//store the textures from the material
uniform sampler2D[TEXTYPES_NUM] Textures;

//Store the multiplers for each texture
uniform float[TEXTYPES_NUM] TMultipliers;

//out unlit override colour
uniform vec3 EmissiveOverride;

//LIGHT VARIABLES


//DIR LIGHT


//Define the number of Dir Lights
const int MAX_LIGHTS_DIR = 3;

//Defining the data for a directional light
struct DirLight {
	vec3 Direction;
	vec3 Colour;
	vec3 Ambience;
};

//how many lights to render 
uniform int NUM_LIGHTS_DIR;

//store the directional light info
uniform DirLight DirLights[MAX_LIGHTS_DIR];


//POINT LIGHTS


//define the number of Point lights
const int MAX_LIGHTS_POINT = 20;

//defining the data for a point light
struct PointLight {
	vec3 Position;
	vec3 Colour;
	float Attenuation;
};

//how many lights to render
uniform int NUM_LIGHTS_POINT;

//store the point light info
uniform PointLight PointLights[MAX_LIGHTS_POINT];

vec3 CalculateSpecPower(vec3 Normal, vec3 LightDir, vec3 ViewDir, vec3 LightColour, float Intensity, float SpecularValue);
vec3 CalculateDirLight(vec3 Normal, vec3 ViewDir, float SpecularValue);
vec3 CalculatePointLight(vec3 Normal, vec3 ViewDir, vec3 VertexPos, float SpecularValue);

void main() {
	// get the colours from the texture
	vec4 BaseColour = texture(Textures[0], TexCoords);
	vec4 SpecularMap = texture(Textures[1], TexCoords);
	vec4 NormalMap = texture(Textures[2], TexCoords);

	//multiply the colour by the multipler value
	BaseColour.rgb *= TMultipliers[0]; 

	//take the red channel for the SpecValue
	SpecularMap.r *= TMultipliers[1];

	//Perform the lighting calculations
	//Direction the vertex is being viewed from
	vec3 ViewDir = normalize(VPosition - CamPosition);
	vec3 Normal = normalize(VNormal);

	if (NormalMap.rgb != vec3(0.0f, 0.0f, 1.0f)) {
		//extract the normal values from the map
		//convert the normal map to a normalized value between 1.0f and -1.0f
		vec3 NormalFromMap = normalize(NormalMap.rgb * 2.0f - 1.0f);

		//algorithm for converting normal maps
		vec3 T = normalize(vec3(0.0f, -1.0f, 1.0f));
		vec3 N = Normal;
		vec3 B = cross(N, T);
		mat3 TBN = mat3(T, B, N);
		Normal = TBN * NormalFromMap;

	}
	
	vec3 DirLightValue = CalculateDirLight(Normal, ViewDir, SpecularMap.r);
	vec3 PointLightValue = CalculatePointLight(Normal, ViewDir, VPosition, SpecularMap.r);

	//combine the light values for the vertex
	vec3 CompleteLightValue = DirLightValue + PointLightValue;

	//Pass the base colour into the colour of the shader
	vec3 FinalColour = BaseColour.rgb * CompleteLightValue;

	if (length(EmissiveOverride) > 0.0f) {
		FinalColour = EmissiveOverride;
	}
	
	//out the final colour considering lighting
	FragColor = vec4(FinalColour, 1.0f);
}

vec3 CalculatePointLight(vec3 Normal, vec3 ViewDir, vec3 VertexPos, float SpecularValue) {
	vec3 Lighting = vec3(0.0f);

	for (int i = 0; i < NUM_LIGHTS_POINT; i++) {
		//Find the direction of the light based on the position of the light against the vertex
		vec3 LightDir = normalize(PointLights[i].Position - VertexPos);

		//find the distance between the light and the vertex
		float Distance = length(PointLights[i].Position - VertexPos);

		//calculate the amount of light the vertex should recieve based on its distance
		//light attentuation * distance squared = between 0 and 1
		float Attenuation = min(PointLights[i].Attenuation / (Distance * Distance), 1.0f);

		//Calculate the intensity of the light based on the direction the vertex is facing
		float Intensity = max(dot(Normal, LightDir), 0.0f);

		//Multiplies out light value based on all of the calculations
		Lighting += Intensity * Attenuation * PointLights[i].Colour;

		//Calculate and add the specular value
		Lighting += CalculateSpecPower(Normal, LightDir, ViewDir, PointLights[i].Colour, Intensity, SpecularValue);
	}

	return Lighting;
}

vec3 CalculateDirLight(vec3 Normal, vec3 ViewDir, float SpecularValue) {
	vec3 Lighting = vec3(0.0f);

	for (int i = 0; i < NUM_LIGHTS_DIR; i++) {
		//reflected light direction
		vec3 LightDir = normalize(-DirLights[i].Direction);

		//determine if the vertex should recieve light based on the direction
		float Intensity = max(dot(Normal, LightDir), 0.0f);

		//apply the light colour to the light based on the intensity
		Lighting += Intensity;

		//add any ambience to the light
		//make sure ambience can't go below 0
		Lighting = max(Lighting, max(DirLights[i].Ambience, vec3(0.0f)));

		//add colour
		Lighting *= DirLights[i].Colour;

		//add the specular lighting
		Lighting += CalculateSpecPower(Normal, LightDir, ViewDir, DirLights[i].Colour, Intensity, SpecularValue);
	}

	return Lighting;
}

vec3 CalculateSpecPower(vec3 Normal, vec3 LightDir, vec3 ViewDir, vec3 LightColour, float Intensity, float SpecularValue) {
	//apply specular using the phong shading model
	float SpecPower = pow(max(dot(ViewDir, reflect(-LightDir, Normal)), 0.0f), SpecularValue * 128.0f);

	return LightColour * Intensity * SpecPower;
}